import os from "node:os";
import path from "node:path";
import process from "node:process";

import { deleteAsync } from "del";
import { dest, parallel, series, src, watch } from "gulp";
import eslint from "gulp-eslint-new";
import htmlhint from "gulp-htmlhint";
import preserveWhitespace from "gulp-preserve-typescript-whitespace";
import prettyError from "gulp-prettyerror";
import gulpSass from "gulp-sass";
import shell from "gulp-shell";
import stylelint from "gulp-stylelint-esm";
import ts from "gulp-typescript";
import zip from "gulp-zip";
import * as dartSass from "sass";
import { quote } from "shell-quote";


function quoted(strings: TemplateStringsArray, ...params: string[]) {
    const res = []
    for (const [i, str] of strings.raw.entries()) {
        res.push(str);
        if (i < params.length) {
            res.push(quote([params[i]]));
        }
    }
    return res.join("");
}

const sass = gulpSass(dartSass);

const tsProject = ts.createProject("tsconfig.json");

const files = {
    types_ts: "ankiwanikanisync/data/files/types.ts",
    types_py: "ankiwanikanisync/types.py",
    types_base: "ankiwanikanisync/",
    py: [
        "ankiwanikanisync/**/*.py",
        "!ankiwanikanisync/pitch/update_accent_data.py",
    ],
    db: [
        "ankiwanikanisync/**/*.(json|csv).xz",
        "ankiwanikanisync/manifest.json",
        "ankiwanikanisync/py.typed",
    ],
    // Note: @(data) is a hack to get the correct glob root.
    ts: [
        "ankiwanikanisync/@(data)/**/*.ts",
        "!**/*.d.ts",
    ],
    js: ["ankiwanikanisync/@(data)/**/*.js"],
    scss: ["ankiwanikanisync/@(data)/**/*.scss"],
    media: ["ankiwanikanisync/@(data)/files/**/*.(woff2|png)"],
    html: ["ankiwanikanisync/@(data)/**/*.html"],
    dist: "dist/",
};

const watchOpts = {
    delay: 200,
};

export function lint_eslint() {
    return src([
        ...files.js,
        ...files.ts,
    ]).pipe(prettyError())
      .pipe(eslint())
      .pipe(eslint.format())
      .pipe(eslint.failAfterError());
}

export function lint_htmlhint() {
    return src(files.html)
      .pipe(prettyError())
      .pipe(htmlhint(".htmlhintrc"))
      .pipe(htmlhint.failAfterError());
}

export function lint_stylelint() {
    return src(files.scss)
        .pipe(prettyError())
        .pipe(stylelint({}));
}

export const generate_types = shell.task([
    quoted`rm -f ${files.types_py}`,
    quoted`ts2python -c3.14 -atoplevel -o ${files.types_base} ${files.types_ts}`,
    quoted`ruff format ${files.types_py}`,
    quoted`sed -i '/type int = float/d; s/\(# Generated by .*\) on .*/\1/' ${files.types_py}`,
    quoted`ruff check --fix ${files.types_py}`,
]);

export function watch_types() {
    return watch([files.types_ts], watchOpts, generate_types);
}

export function watch_eslint() {
    return watch([
        ...files.js,
        ...files.ts,
    ], watchOpts, lint_eslint);
}

export function watch_htmlhint() {
    return watch(files.html, watchOpts, lint_htmlhint);
}

export function watch_stylelint() {
    return watch(files.scss, watchOpts, lint_stylelint);
}

export const lint = parallel(lint_eslint, lint_htmlhint, lint_stylelint);

export function build_scss() {
    return src(files.scss)
        // eslint-disable-next-line @typescript-eslint/unbound-method
        .pipe(sass().on("error", sass.logError))
        .pipe(dest(files.dist))
}

export function watch_scss() {
    return watch(files.scss, watchOpts, build_scss);
}

export function build_static() {
    return src([
        ...files.html,
        ...files.js,
        ...files.media,
        ...files.db,
        ...files.py,
    ]).pipe(dest(files.dist));
}

export function build_tf() {
    return src([
        ...files.db,
        ...files.py,
    ]).pipe(dest(files.dist));
}

export function watch_static() {
    return watch([
        ...files.html,
        ...files.js,
        ...files.media,
        ...files.db,
        ...files.py,
    ], watchOpts, build_static);
}

export function build_ts() {
    return src(files.ts).pipe(preserveWhitespace.saveWhitespace())
                        .pipe(tsProject())
                        .js
                        .pipe(preserveWhitespace.restoreWhitespace())
                        .pipe(dest(files.dist));
}

export function watch_ts() {
    return watch(files.ts, watchOpts, build_ts);
}

export function clean() {
    return deleteAsync(`${files.dist}**/*`);
}

export const build = series(
    parallel(
        clean,
        generate_types,
    ),
    parallel(
        build_scss,
        build_static,
        build_ts,
        lint,
    ));

function getInstallPath(): string {
    if (process.env.ANKIWANIKANISYNC_INSTALL_PATH) {
        return process.env.ANKIWANIKANISYNC_INSTALL_PATH;
    }
    const home = os.homedir();
    let dir: string;
    switch (os.platform()) {
        case "darwin":
            dir = path.join(home, "Library/Application Support/Anki2");
            break;
        case "win32":
            dir = path.join(process.env.APPDATA, "Anki2");
            break;
        default:
            dir = path.join(
                process.env.XDG_DATA_HOME || path.join(home, ".local/share/"),
                "Anki2");
    }
    return path.join(dir, "addons21/ankiwanikanisync");
}

function relativePath(pathStr: string): string {
    return path.relative(import.meta.dirname, pathStr).replace("\\", "/");
}

function doInstall() {
    return src(`${files.dist}**/*`)
        .pipe(dest(`${relativePath(getInstallPath())}/`));
}

export const install = series(build, doInstall);

export function export_zip() {
    return src(`${files.dist}**/*`)
        .pipe(zip("ankiwanikanisync.zip"))
        .pipe(dest("./"));
}

export const dist = series(build, export_zip)

export function watch_dist() {
    return watch(`${files.dist}**/*`, watchOpts, doInstall);
}

export const watch_lint = parallel(
    watch_eslint,
    watch_htmlhint,
    watch_stylelint,
);

export const watch_all = parallel(
    watch_scss,
    watch_static,
    watch_ts,
    watch_dist,
    watch_types,
);
